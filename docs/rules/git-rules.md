### Git 操作ルール (ベストプラクティス)

このプロジェクトでは、以下のGit操作ルールを遵守し、クリーンで追跡しやすい履歴を維持します。

1. **ブランチ戦略: フィーチャーブランチワークフロー**
   - `main` ブランチは常にデプロイ可能な状態を保ちます。直接コミットは禁止です。
   - 新機能の開発、バグ修正、大規模なリファクタリングは、必ず `main`
     から派生したフィーチャーブランチで行います。
   - フィーチャーブランチは、作業が完了し、レビューが承認された後にのみ `main`
     にマージされます.

2. **ブランチ命名規則**
   - ブランチ名は、その目的を明確に示すようにします。以下のプレフィックスの使用を推奨します。
     - `feat/`: 新機能の開発
     - `fix/`: バグ修正
     - `hotfix/`: 緊急の修正（本番環境向け）
     - `chore/`: メンテナンス作業、ビルドプロセスの変更など
   - 例: `feat/add-user-auth`, `bugfix/login-issue`,
     `hotfix/critical-security-patch`
   - 必要に応じて、JIRAなどのチケット番号を含めることも検討してください（例:
     `feat/JIRA123-add-login`）。

3. **コミットメッセージ: セマンティックコミットの仕様**
   このプロジェクトでは、[Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/)
   の仕様に準拠したセマンティックコミットメッセージを義務付けます。これにより、変更履歴の自動生成、セマンティックバージョニング、およびツールによるコミット内容の理解が可能になります。

   **フォーマット:**

   ```
   <type>[optional scope]: <description>

   [optional body]

   [optional footer(s)]
   ```

   **ルール:**
   - **`<type>` (必須):** コミットの種類を示します。以下のいずれかを使用します。
     - `feat`: 新機能の追加 (minor バージョンアップに相当)
     - `fix`: バグ修正 (patch バージョンアップに相当)
     - `docs`: ドキュメントのみの変更
     - `style`: コードの整形、セミコロンの欠落など (ロジックに影響しない変更)
     - `refactor`: リファクタリング (バグ修正や機能追加を含まないコード変更)
     - `perf`: パフォーマンスを改善するコード変更
     - `test`: テストの追加または修正
     - `chore`: ビルドプロセスや補助ツールの変更、ライブラリの依存関係の更新など (ソースコードやテストの変更を含まない)
     - `build`: ビルドシステムや外部依存に関する変更 (例: gulp, broccoli, npm)
     - `ci`: CIの設定ファイルやスクリプトに関する変更 (例: Travis, Circle,
       BrowserStack, SauceLabs)
     - `revert`: 以前のコミットを元に戻すコミット

   - **`[optional scope]` (任意):** 変更が影響する範囲を括弧 `()`
     で囲んで記述します。例: `feat(parser):`。

   - **`<description>` (必須):** 変更の簡潔な説明を英語で記述します。
     - 命令形を使用します（例: "fix bug" ではなく "Fix bug"）。
     - 最初の文字を大文字にします。
     - 末尾にピリオドを付けません。
     - 50文字以内に収めることを推奨します。

   - **コミットメッセージは英語のみとします。**
     これは、グローバルな開発チームにおける普遍的な理解、将来的なメンテナンスの容易さ、および様々な自動化ツールとの互換性を確保するためです。

   - **`[optional body]` (任意):** コミットのより詳細な説明を記述します。
     - 1行空けてから記述を開始します。
     - 各行は72文字で折り返すことを推奨します。
     - 変更の「理由」と「方法」を説明します。
     - **複数行のコミットメッセージの記述方法:** `git commit`
       コマンドで複数行のメッセージを記述する場合、最初の `-m`
       オプションで件名（Subject）を指定し、その後の各行を別の `-m`
       オプションで指定します。例:
       `git commit -m "feat: Add new feature" -m "This commit introduces a new feature that does X." -m "It also addresses Y and Z."`

   - **`[optional footer(s)]` (任意):** 以下の情報を記述できます。
     - **Breaking Changes:** 破壊的変更がある場合は、`BREAKING CHANGE:` または
       `BREAKING-CHANGE:`
       で開始し、その変更がなぜ破壊的であるか、および移行方法を記述します (major バージョンアップに相当)。
     - **Issue References:** 関連するIssueやタスクを `Closes #123`, `Fixes #456`
       などの形式で参照します。

   **ツール化の検討:** これらのルールは、`commitlint` や `husky`
   などのGitフックツールを使用して、コミットメッセージが仕様に準拠しているかを自動的に検証するために利用できます。これにより、プロジェクト全体のコミット履歴の一貫性と品質が保証されます。

   **導入と運用に関する知見:**
   - **`husky` と `commitlint` の導入:**
     `npm install --save-dev husky @commitlint/config-conventional @commitlint/cli`
     でインストールし、`npx husky init` と
     `npm pkg set scripts.prepare="husky install"`
     で初期設定を行います。コミットメッセージの検証は `.husky/commit-msg`
     ファイルに `npx --no-install commitlint --edit $1`
     を記述することで有効になります。
   - **コミットメッセージ本文の文字数制限:** `commitlint`
     はデフォルトでコミットメッセージの本文の行長を100文字に制限します。`GIT_RULES.md`
     では72文字を推奨していますが、ツールによる自動検証ではこの制限に注意が必要です。長い説明が必要な場合は、複数行に分割してください。
   - **Gitフックの適切な設定:** `husky`
     のフックが正しく機能するためには、`npm install` 後に `npm run prepare`
     が実行される必要があります。これにより、`.husky`
     ディレクトリ内のフックが有効になります。
   - **`pre-commit` フックの注意点:** `pre-commit`
     フックはコミット前に実行されるため、意図しないスクリプト（例: `npm test`
     のようなエラーで終了する可能性のあるスクリプト）が実行されないように注意してください。コミットメッセージの検証は
     `commit-msg` フックで行うべきです。

4. **コミットの粒度**
   - 変更は論理的な単位で細かくコミットします。これにより、履歴が読みやすくなり、問題発生時の特定が容易になります。
   - 未完成の機能やデバッグ用のコードを `main`
     にマージする前にコミットしないようにします。

5. **プルリクエスト (PR) とコードレビュー**
   - フィーチャーブランチを `main`
     にマージする際は、必ずプルリクエストを作成し、少なくとも1人のレビュアーによる承認を得ます。
   - PRの目的、変更内容、テスト方法などを明確に記述します。

6. **履歴の整理 (Rebase, Merge, Squash)**
   - フィーチャーブランチを `main` にマージする前に、`main`
     の最新の変更をフィーチャーブランチに取り込む際は、可能であれば
     `git rebase main` を使用して履歴をクリーンに保つことを推奨します。
   - ただし、共有ブランチや既にリモートにプッシュされているコミットに対しては、`rebase`
     は避けて `merge` を使用します。
   - フィーチャーブランチに多くの小さなコミットがある場合、`main`
     ブランチの履歴をクリーンに保つために、マージする前にそれらを単一の論理的なコミットにスカッシュすることを検討してください。

7. **機密情報の取り扱い**
   - APIキー、パスワード、個人情報などの機密情報は、絶対にGitリポジトリにコミットしないでください。
   - `.gitignore` を適切に設定し、誤ってコミットされるのを防ぎます。

8. **ブランチの最新化**
   - 作業を開始する前やPRを作成する前に、常に `main` ブランチを `git pull`
     で最新の状態に保ち、フィーチャーブランチに定期的に取り込むことで、マージの競合を最小限に抑えます。

9. **リリースのタグ付け**
   - リリースなどの特定の履歴ポイントには、Gitタグ (`v1.0.0`
     など) を使用してマークを付けます。

10. **大きなバイナリファイルの回避**
    - 大きなバイナリファイルは、リポジトリのサイズを肥大化させるため、Gitリポジトリに直接コミットせず、Git
      LFSなどの別のシステムに保存することを検討してください。
